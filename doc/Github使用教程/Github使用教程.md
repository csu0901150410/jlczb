1、准备上网环境
国内访问github有时候连接不稳定，最好准备好梯子。

2、注册github账号
梯子系统代理开启之后，访问[Github](https://github.com/)网页，点击网页右上角的Sign up进行注册，注册成功后点击右上角的Sign in登录进去。

3、创建github代码仓库
Github是一个[代码托管服务平台](https://zh.wikipedia.org/wiki/GitHub)，我们可以在github上创建代码仓库，再将github上的远程仓库克隆到本地，本地对仓库进行修改后再推送同步到远程仓库。在多人协作时，可以通过克隆同一个远程仓库，各自本地修改，然后提交到同一个远程仓库完成协作。

在访问github页面成功后，点击右上角的+号，在下拉列表中选择New repositoy新建仓库。
![[Pasted image 20240623004501.png]]

接着填写仓库名称、公开/私有、添加初始README文件（不要也可以）之后，就可以点击右下角的按钮创建仓库了。
![[Pasted image 20240623005002.png]]

仓库创建好之后，会自动跳转到新创建仓库的界面，点击右上角code按钮，复制仓库链接以便克隆到本地。
![[Pasted image 20240623005309.png]]

4、安装Git
[Git](https://zh.wikipedia.org/wiki/Git)是一个版本控制软件，可以用它将远程仓库克隆到本地。访问[Git官网](https://git-scm.com/downloads)下载Windows系统版本的安装包进行安装。安装过程随便找一个[教程](https://blog.csdn.net/mukes/article/details/115693833)看看了解下即可，真实的安装教程是除了选一下安装位置，其他的一路next即可。

安装完毕之后在需要存放克隆仓库的文件夹下右键，此时应能找到Git Bash Here的选项，点击即可打开gitbash终端窗口，在该终端窗口内输入`git clone https://github.com/csu0901150410/jlczb.git`就可以将远程仓库克隆到本地了。命令执行成功之后，本地多了一个jlczb文件夹，并且其内有一个README文件，这和远程仓库一致。
![[Pasted image 20240623010323.png]]

注意一：由于网络的原因，这一步有可能会执行失败，这有可能涉及到使用代理的问题，可以通过在gitbash终端中输入以下指令设置或者取消代理。
```bash
# 设置代理 1080是代理的端口号
git config --global https.proxy http://127.0.0.1:1080
git config --global https.proxy https://127.0.0.1:1080

# 取消代理
git config --global --unset http.proxy
git config --global --unset https.proxy
```

一般端口号可以到代理软件查看，比如Clash的可以如下所示查看。
![[Pasted image 20240623011348.png]]

注意二：考虑到后续的git提交，还需要设置用户名和邮箱，具体可参考[这篇博客](https://blog.csdn.net/xingbaozhen1210/article/details/80342212)。
```bash
# 替换其中的用户名和邮箱为需要设置的
git config --global user.name "用户名"
git config --global user.email 邮箱@qq.com
```

5、提交仓库修改
远程仓库克隆到本地之后，会在本地对仓库进行修改，比如添加/删除/修改文件等，将修改过的仓库同步到远程仓库需要经过本地提交、拉取远程、本地合并、推送远程四个步骤。以下通过一个简单的例子说明这四个步骤。

假设A和B通过同一个远程仓库协作，他们各自将当前最新的远程仓库克隆到本地进行修改，也就是说在克隆之后，他们的本地仓库是相同的。A首先将其中一个文件的第100行修改了，然后将修改同步到远程仓库了，这时候远程仓库的这个文件的第100行是A修改过的。之后B对他的本地仓库进行了修改，其中也涉及这个文件第100行的修改，并且修改和A不相同。这时候B要同步到远程仓库了，B先将自己的本地修改提交到本地的记录了，由于B不知道这时候远程仓库是不是还是保持着克隆仓库时的状态，于是B先拉取远程仓库，发现A已经在克隆时的版本上提交了一个版本，现在B的本地存在了两个版本，一个是B提交的，另一个是A提交的，这两个版本的父版本都是同一个，这不行，远程仓库的提交记录必须是有先后顺序的。所以B进行了一个合并，将自己的本地提交和A的远程提交合并，这里可以认为是，B先将自己本地的父版本升级了一下，更新到A提交到远程仓库的那个状态，再将自己的本地提交给叠加上去。这时候，冲突就出来了，要合并的两个版本对同一个文件的相同位置进行了不同的修改，以谁的为准，需要合并者也就是B来决定。当B在合并过程中将冲突处理完之后，B要将因合并处理冲突产生的修改再次提交到本地，这时候B已经将他本地修改期间远程仓库的变动同步到本地并且将本地修改全部提交本地了，就可以将所有本地提交记录推送到远程仓库了。

回到jlczb这个仓库，先在仓库目录下新增一个文件test，输入`git status`可以查看本地仓库状态，命令执行结果提示，仓库下出现了未跟踪文件（Untracked files），为了将这个文件记录在案，输入`git add test`将新增且未被git跟踪记录的文件添加到记录中，再次查看仓库状态是多了新文件（new file）。
![[Pasted image 20240623014110.png]]

注意，这时候只是将文件记录在案，但是并未将这次修改固定下来形成一次提交记录。输入`git log -n 5`查看最新的5条提交记录，发现目前本地仓库只有一个提交记录，接着输入`git commit -m "xxx"`将本地的所有已记录修改一次提交到本地，并执行提交的说明信息为xxx，本地提交之后，再查看提交记录，可以发现本地提交多了一条记录，正是刚才的提交。
![[Pasted image 20240623015003.png]]

本地提交完成之后，可以输入`git pull`拉取最新并合并本地（就不演示了，比较麻烦）。假设远程仓库没有更新，输入`git push`直接提交。
![[Pasted image 20240623015654.png]]

推送远程仓库之后，刷新远程仓库网页，即可看到最新推送上去的提交。
![[Pasted image 20240623015841.png]]